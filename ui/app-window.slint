import { Button, VerticalBox, TextEdit, SpinBox, CheckBox, ScrollView, Slider, HorizontalBox } from "std-widgets.slint";

import "./res/fonts/Neucha-Regular.ttf";
import "./res/fonts/RubikMoonrocks-Regular.ttf";
import "./res/fonts/IrishGrover-Regular.ttf";

import { MyButton } from "./my-button.slint";
import { Player } from "player.slint";
import { Settings } from "settings.slint";

export component AppWindow inherits Window {
    // no-frame: true;
    default-font-family: "Neucha";
    // default-font-family: "RubikMoonrocks";
    default-font-size: 24px;

    title: "Wav-wav!";
    icon: @image-url("res/icons/dog.png");

    callback choose_audio_file() -> {filename: string, duration: float};
    callback save_audio_file() -> string;

    callback input_play_toggle <=> input_player.play_button_clicked;
    callback output_play_toggle <=> output_player.play_button_clicked;

    callback input_seek <=> input_player.seek_audio;
    callback output_seek <=> output_player.seek_audio;

    in-out property <float> input_playback_position: 0.0;
    in-out property <float> output_playback_position: 0.0;
    in-out property <bool> input_is_playing <=> input_player.playing;
    in-out property <bool> output_is_playing <=> output_player.playing;

    in-out property <string> message-text <=> text-input.text;

    callback decode(bool, int) -> string;
    callback encode(bool, int, string);

    // max-width: 1440px;
    // max-height: 1024px;
    min-width: 720px;
    min-height: 512px;

    Image {
        source: @image-url("res/background.png");
        image-fit: cover;
        width: parent.width;
        height: parent.height;
    }
    // in-out property <int> counter: 42;
    // callback request-increase-value();


        VerticalLayout {
        padding: 10px;
        spacing: 10px;
        input_player := Player {
            filename: "< No File >";
            position <=> root.input_playback_position;

            out property <{filename: string, duration: float}> new;
            file_button_clicked => {
                new = root.choose_audio_file();
                self.filename = new.filename == "" ? self.filename : new.filename;
                self.duration = new.filename == "" ? self.duration : new.duration + 0.001; // avoid division by zero
                    self.playing = self.playing ? self.play_button_clicked() : self.playing;
            }
        }

        decode-settings := Settings {
            check-box-text: "скрыть повторы";
            button-text: "де-шифр";
            button-clicked => {
                message-text = root.decode(self.repeating, self.bits);
            }
        }

        Rectangle {
            background: black.transparentize(30%);
            border-radius: 8px;

            in property <length> text-margin: 20px;

            scroll-bar-line := Rectangle {
                in property <length> bar-width: 5px;

                x: parent.width - 2 * bar-width;
                y: bar-width;
                border-radius: 3px;
                width: bar-width;
                height: parent.height - 2 * bar-width;
                background: flickable-ratio < 1. ? black.transparentize(50%) : transparent;

                in property <float> flickable-ratio: (text-input-flickable.height / text-input-flickable.viewport-height).min(1);
                in property <length> flickable-diff: (text-input-flickable.viewport-height - text-input-flickable.height);
                TouchArea {
                    in-out property <float> anchor;
                    y: 0px;
                    height: parent.height;
                    width: 10 * parent.width;
                    x: parent.width / 2 - self.width / 2;
                    moved => {
                        anchor = (self.mouse-y - self.pressed-y).abs() < 4px ? (-text-input-flickable.viewport-y / flickable-diff) : anchor;
                        text-input-flickable.viewport-y = -(anchor + (self.mouse-y - self.pressed-y) / (parent.height - scroll-bar.height)).clamp(0, 1) * flickable-diff;
                    }
                }

                scroll-bar := Rectangle {
                    x: 0;
                    width: parent.bar-width;
                    border-radius: parent.border-radius;

                    background: flickable-ratio < 1. ? white : transparent;

                    height: parent.height * flickable-ratio;
                    y: (parent.height - self.height) * (- text-input-flickable.viewport-y) / flickable-diff;
                }
            }

            text-input-flickable := Flickable {
                height: parent.height - 2 * text-margin;
                width: parent.width - 2 * text-margin;
                viewport-height: text-input.min-height;
                interactive: false;
                Text {
                    x: 0px;
                    y: 0px;
                    color: white.transparentize(50%);
                    text: text-input.text == "" ? "Сообщение после дешифровки или для шифрования" : "";
                }

                text-input := TextInput {
                    x: 0px;
                    y: 0px;
                    font-family: "Neucha";
                    height: self.min-height;
                    width: parent.width;
                    color: white;
                    text: "";
                    single-line: false;
                    wrap: TextWrap.char-wrap;
                    selection-foreground-color: black;
                    selection-background-color: white;

                    cursor-position-changed(p) => {
                        text-input-flickable.viewport-y = text-input-flickable.viewport-y.clamp(-p.y, -(p.y - parent.height + 30px));
                    }
                }
            }
        }

        encode-settings := Settings {
            check-box-text: "сделать повторы";
            button-text: "шифр";

            button-clicked => {
                root.encode(self.repeating, self.bits, message-text);
                output-player.filename = "< Unsaved audio >";
                output-player.duration = input-player.duration;
            }
        }

        output-player := Player {
            file-button-text: "Сохранить файл";
            filename: "< No File >";
            position <=> root.output_playback_position;

            out property <string> new-filename;
            file_button_clicked => {
                self.playing = self.playing ? self.play_button_clicked() : self.playing;
                new-filename = root.save_audio_file();
                self.filename = new-filename == "" ? self.filename : new-filename;
            }
        }
    }
}
